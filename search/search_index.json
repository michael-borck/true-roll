{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to TrueRoll TrueRoll is a comprehensive simulation library for ten-pin bowling, designed to model games, analyze player performance, and investigate the impacts of various environmental and personal factors on gameplay. Overview Bowling, as a sport, involves numerous variables that can influence the outcome of a game, from the skill level of the players to the characteristics of the bowling alley. TrueRoll aims to provide a realistic and flexible simulation environment where these variables can be controlled and studied. Whether you're a data scientist, a coach, or a bowling enthusiast, TrueRoll offers tools to simulate, analyze, and understand the nuances of ten-pin bowling. Features TrueRoll includes several key features: Game Simulation: Simulate complete games with detailed control over player attributes and alley conditions. Scoring Systems: Support for various scoring systems including traditional, current frame, and 9-pin no-tap. Statistical Analysis: Tools to analyze game outcomes, providing insights into performance metrics such as strike rates, spare conversions, and overall scores. Data Management: Integration with a SQLite database to store and retrieve game records, player profiles, and alley specifications for longitudinal studies and performance tracking. Extensibility: Designed with extensibility in mind, allowing users to add new types of analyses, scoring rules, or even different bowling games like duckpin or candlepin bowling. Getting Started To get started with TrueRoll, you'll need to have Python installed on your machine, along with Poetry for dependency management. Clone the repository, install dependencies, and you're ready to start simulating your own bowling games. git clone https://github.com/yourgithubusername/trueroll.git cd trueroll poetry install You can then dive into simulating games or analyzing bowling data by following the examples provided in the documentation. Documentation This documentation is structured to help you find what you need: Installation Guide: Detailed instructions on setting up TrueRoll on your system. User Guide: How to use TrueRoll to simulate games and analyze data. API Reference: Comprehensive details about the functions and classes available in TrueRoll. Examples: Practical examples and case studies using TrueRoll. Contributing TrueRoll is an open-source project, and contributions are welcome. Check out the contributing guidelines to see how you can make a difference, whether through code, documentation, or community support. License TrueRoll is released under the MIT license. This choice ensures that the software can be freely used, modified, and shared. Thank you for visiting the TrueRoll documentation. We hope you find this project useful for your bowling simulation and analysis needs!","title":"Home"},{"location":"#welcome-to-trueroll","text":"TrueRoll is a comprehensive simulation library for ten-pin bowling, designed to model games, analyze player performance, and investigate the impacts of various environmental and personal factors on gameplay.","title":"Welcome to TrueRoll"},{"location":"#overview","text":"Bowling, as a sport, involves numerous variables that can influence the outcome of a game, from the skill level of the players to the characteristics of the bowling alley. TrueRoll aims to provide a realistic and flexible simulation environment where these variables can be controlled and studied. Whether you're a data scientist, a coach, or a bowling enthusiast, TrueRoll offers tools to simulate, analyze, and understand the nuances of ten-pin bowling.","title":"Overview"},{"location":"#features","text":"TrueRoll includes several key features: Game Simulation: Simulate complete games with detailed control over player attributes and alley conditions. Scoring Systems: Support for various scoring systems including traditional, current frame, and 9-pin no-tap. Statistical Analysis: Tools to analyze game outcomes, providing insights into performance metrics such as strike rates, spare conversions, and overall scores. Data Management: Integration with a SQLite database to store and retrieve game records, player profiles, and alley specifications for longitudinal studies and performance tracking. Extensibility: Designed with extensibility in mind, allowing users to add new types of analyses, scoring rules, or even different bowling games like duckpin or candlepin bowling.","title":"Features"},{"location":"#getting-started","text":"To get started with TrueRoll, you'll need to have Python installed on your machine, along with Poetry for dependency management. Clone the repository, install dependencies, and you're ready to start simulating your own bowling games. git clone https://github.com/yourgithubusername/trueroll.git cd trueroll poetry install You can then dive into simulating games or analyzing bowling data by following the examples provided in the documentation.","title":"Getting Started"},{"location":"#documentation","text":"This documentation is structured to help you find what you need: Installation Guide: Detailed instructions on setting up TrueRoll on your system. User Guide: How to use TrueRoll to simulate games and analyze data. API Reference: Comprehensive details about the functions and classes available in TrueRoll. Examples: Practical examples and case studies using TrueRoll.","title":"Documentation"},{"location":"#contributing","text":"TrueRoll is an open-source project, and contributions are welcome. Check out the contributing guidelines to see how you can make a difference, whether through code, documentation, or community support.","title":"Contributing"},{"location":"#license","text":"TrueRoll is released under the MIT license. This choice ensures that the software can be freely used, modified, and shared. Thank you for visiting the TrueRoll documentation. We hope you find this project useful for your bowling simulation and analysis needs!","title":"License"},{"location":"api/","text":"Alley Class Represents a bowling alley where games are played, including details about the lane conditions. Attributes: name ( str ) \u2013 The name of the alley. location ( str ) \u2013 The geographic location of the alley. lane_type ( str ) \u2013 The type of lane surface, such as 'Wood' or 'Synthetic'. Source code in trueroll/alley.py class Alley: \"\"\" Represents a bowling alley where games are played, including details about the lane conditions. Attributes: name (str): The name of the alley. location (str): The geographic location of the alley. lane_type (str): The type of lane surface, such as 'Wood' or 'Synthetic'. \"\"\" VALID_LANE_TYPES = {'wood', 'synthetic'} def __init__(self, name: str, location: str, lane_type: str): \"\"\" Initialize a new Alley instance. Parameters: name (str): The name of the alley. location (str): The geographic location of the alley. lane_type (str): The type of lane surface, indicating the material of the bowling lane. Raises: ValueError: If lane_type is not 'Wood' or 'Synthetic'. \"\"\" self.name = name self.location = location if lane_type.lower() not in self.VALID_LANE_TYPES: raise ValueError(f\"Invalid lane type '{lane_type}'. Valid types are: 'Wood', 'Synthetic'\") self.lane_type = lane_type.capitalize() def __str__(self): \"\"\" Return a string representation of the Alley instance, which is helpful for debugging and logging. Returns: str: A string that represents this Alley. \"\"\" return f\"{self.name} - {self.location} ({self.lane_type})\" __init__(name, location, lane_type) Initialize a new Alley instance. Parameters: name ( str ) \u2013 The name of the alley. location ( str ) \u2013 The geographic location of the alley. lane_type ( str ) \u2013 The type of lane surface, indicating the material of the bowling lane. Raises: ValueError \u2013 If lane_type is not 'Wood' or 'Synthetic'. Source code in trueroll/alley.py def __init__(self, name: str, location: str, lane_type: str): \"\"\" Initialize a new Alley instance. Parameters: name (str): The name of the alley. location (str): The geographic location of the alley. lane_type (str): The type of lane surface, indicating the material of the bowling lane. Raises: ValueError: If lane_type is not 'Wood' or 'Synthetic'. \"\"\" self.name = name self.location = location if lane_type.lower() not in self.VALID_LANE_TYPES: raise ValueError(f\"Invalid lane type '{lane_type}'. Valid types are: 'Wood', 'Synthetic'\") self.lane_type = lane_type.capitalize() __str__() Return a string representation of the Alley instance, which is helpful for debugging and logging. Returns: str \u2013 A string that represents this Alley. Source code in trueroll/alley.py def __str__(self): \"\"\" Return a string representation of the Alley instance, which is helpful for debugging and logging. Returns: str: A string that represents this Alley. \"\"\" return f\"{self.name} - {self.location} ({self.lane_type})\" Bowler Class Represents a bowler in a bowling simulation, including probabilities for striking and sparing, as well as personal characteristics like handedness and bowling technique. Attributes: name ( str ) \u2013 The name of the bowler. strike_prob ( float ) \u2013 Probability of hitting a strike. spare_prob ( float ) \u2013 Probability of hitting a spare. handedness ( str ) \u2013 The preferred hand of the bowler, either 'left' or 'right'. technique ( str ) \u2013 The bowling technique used, either 'single' or 'double' handed. Source code in trueroll/bowler.py class Bowler: \"\"\" Represents a bowler in a bowling simulation, including probabilities for striking and sparing, as well as personal characteristics like handedness and bowling technique. Attributes: name (str): The name of the bowler. strike_prob (float): Probability of hitting a strike. spare_prob (float): Probability of hitting a spare. handedness (str): The preferred hand of the bowler, either 'left' or 'right'. technique (str): The bowling technique used, either 'single' or 'double' handed. \"\"\" def __init__(self, name: str, strike_prob: float, spare_prob: float, handedness: str = 'right', technique: str = 'single'): \"\"\" Initializes a new instance of Bowler. Parameters: name (str): The name of the bowler. strike_prob (float): Probability of hitting a strike, between 0 and 1. spare_prob (float): Probability of hitting a spare, between 0 and 1. handedness (str): The preferred hand of the bowler, either 'left' or 'right' (default 'right'). technique (str): The bowling technique used by the bowler, either 'single' or 'double' handed (default 'single'). Raises: ValueError: If strike_prob or spare_prob is greater than 1. \"\"\" if not (0 <= strike_prob <= 1): raise ValueError(f\"Invalid strike probability {strike_prob}. Must be between 0 and 1.\") if not (0 <= spare_prob <= 1): raise ValueError(f\"Invalid spare probability {spare_prob}. Must be between 0 and 1.\") if handedness not in ['left', 'right']: raise ValueError(f\"Invalid handedness '{handedness}'. Must be 'left' or 'right'.\") if technique not in ['single', 'double']: raise ValueError(f\"Invalid technique '{technique}'. Must be 'single' or 'double'.\") self.name = name self.strike_prob = strike_prob self.spare_prob = spare_prob self.handedness = handedness self.technique = technique def __str__(self): \"\"\" Returns a string representation of the Bowler instance. Returns: str: A string that includes all the attributes of the Bowler. \"\"\" return (f\"Bowler(Name: {self.name}, Strike Probability: {self.strike_prob}, \" f\"Spare Probability: {self.spare_prob}, Handedness: {self.handedness}, \" f\"Technique: {self.technique})\") __init__(name, strike_prob, spare_prob, handedness='right', technique='single') Initializes a new instance of Bowler. Parameters: name ( str ) \u2013 The name of the bowler. strike_prob ( float ) \u2013 Probability of hitting a strike, between 0 and 1. spare_prob ( float ) \u2013 Probability of hitting a spare, between 0 and 1. handedness ( str , default: 'right' ) \u2013 The preferred hand of the bowler, either 'left' or 'right' (default 'right'). technique ( str , default: 'single' ) \u2013 The bowling technique used by the bowler, either 'single' or 'double' handed (default 'single'). Raises: ValueError \u2013 If strike_prob or spare_prob is greater than 1. Source code in trueroll/bowler.py def __init__(self, name: str, strike_prob: float, spare_prob: float, handedness: str = 'right', technique: str = 'single'): \"\"\" Initializes a new instance of Bowler. Parameters: name (str): The name of the bowler. strike_prob (float): Probability of hitting a strike, between 0 and 1. spare_prob (float): Probability of hitting a spare, between 0 and 1. handedness (str): The preferred hand of the bowler, either 'left' or 'right' (default 'right'). technique (str): The bowling technique used by the bowler, either 'single' or 'double' handed (default 'single'). Raises: ValueError: If strike_prob or spare_prob is greater than 1. \"\"\" if not (0 <= strike_prob <= 1): raise ValueError(f\"Invalid strike probability {strike_prob}. Must be between 0 and 1.\") if not (0 <= spare_prob <= 1): raise ValueError(f\"Invalid spare probability {spare_prob}. Must be between 0 and 1.\") if handedness not in ['left', 'right']: raise ValueError(f\"Invalid handedness '{handedness}'. Must be 'left' or 'right'.\") if technique not in ['single', 'double']: raise ValueError(f\"Invalid technique '{technique}'. Must be 'single' or 'double'.\") self.name = name self.strike_prob = strike_prob self.spare_prob = spare_prob self.handedness = handedness self.technique = technique __str__() Returns a string representation of the Bowler instance. Returns: str \u2013 A string that includes all the attributes of the Bowler. Source code in trueroll/bowler.py def __str__(self): \"\"\" Returns a string representation of the Bowler instance. Returns: str: A string that includes all the attributes of the Bowler. \"\"\" return (f\"Bowler(Name: {self.name}, Strike Probability: {self.strike_prob}, \" f\"Spare Probability: {self.spare_prob}, Handedness: {self.handedness}, \" f\"Technique: {self.technique})\") Scoring Class Source code in trueroll/scoring.py class Scoring: @staticmethod def traditional(frames: list) -> int: \"\"\" Calculate the traditional bowling score from a list of frames. Each frame should be represented by a tuple indicating the number of pins knocked down in each roll. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on traditional bowling rules. \"\"\" score = 0 for i in range(10): frame = frames[i] # Strike if frame[0] == 10: score += 10 if i < 9: next_frame = frames[i + 1] if next_frame[0] == 10: score += 10 if i + 1 < 9: score += frames[i + 2][0] else: score += next_frame[1] else: score += next_frame[0] + next_frame[1] else: score += frame[1] + frame[2] # Spare elif sum(frame) == 10: score += 10 if i < 9: score += frames[i + 1][0] else: score += frame[2] # Open frame else: score += sum(frame) return score @staticmethod def current_frame(frames: list) -> int: \"\"\" Calculate the score using current frame scoring rules, also known as World Bowling scoring. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on current frame (World Bowling) rules. \"\"\" score = 0 for frame in frames: if frame[0] == 10: # Strike score += 30 elif sum(frame) == 10: # Spare score += 10 + frame[0] else: score += sum(frame) return score @staticmethod def nine_pin_no_tap(frames: list) -> int: \"\"\" Calculate the score for a 9-pin no-tap game, where knocking down 9 pins counts as a strike. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on 9-pin no-tap rules. \"\"\" score = 0 for i, frame in enumerate(frames): first_roll = frame[0] if first_roll == 9 or first_roll == 10: if i < 9: # Not the last frame next_frame = frames[i + 1] score += 10 + next_frame[0] + (next_frame[1] if len(next_frame) > 1 else 0) else: # Last frame score += 10 + frame[1] + frame[2] elif sum(frame[:2]) == 10: # Spare score += 10 + (frames[i + 1][0] if i < 9 else frame[2]) else: score += sum(frame) return score current_frame(frames) staticmethod Calculate the score using current frame scoring rules, also known as World Bowling scoring. Parameters: frames ( list ) \u2013 A list of tuples representing the game frames. Returns: int ( int ) \u2013 The total score calculated based on current frame (World Bowling) rules. Source code in trueroll/scoring.py @staticmethod def current_frame(frames: list) -> int: \"\"\" Calculate the score using current frame scoring rules, also known as World Bowling scoring. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on current frame (World Bowling) rules. \"\"\" score = 0 for frame in frames: if frame[0] == 10: # Strike score += 30 elif sum(frame) == 10: # Spare score += 10 + frame[0] else: score += sum(frame) return score nine_pin_no_tap(frames) staticmethod Calculate the score for a 9-pin no-tap game, where knocking down 9 pins counts as a strike. Parameters: frames ( list ) \u2013 A list of tuples representing the game frames. Returns: int ( int ) \u2013 The total score calculated based on 9-pin no-tap rules. Source code in trueroll/scoring.py @staticmethod def nine_pin_no_tap(frames: list) -> int: \"\"\" Calculate the score for a 9-pin no-tap game, where knocking down 9 pins counts as a strike. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on 9-pin no-tap rules. \"\"\" score = 0 for i, frame in enumerate(frames): first_roll = frame[0] if first_roll == 9 or first_roll == 10: if i < 9: # Not the last frame next_frame = frames[i + 1] score += 10 + next_frame[0] + (next_frame[1] if len(next_frame) > 1 else 0) else: # Last frame score += 10 + frame[1] + frame[2] elif sum(frame[:2]) == 10: # Spare score += 10 + (frames[i + 1][0] if i < 9 else frame[2]) else: score += sum(frame) return score traditional(frames) staticmethod Calculate the traditional bowling score from a list of frames. Each frame should be represented by a tuple indicating the number of pins knocked down in each roll. Parameters: frames ( list ) \u2013 A list of tuples representing the game frames. Returns: int ( int ) \u2013 The total score calculated based on traditional bowling rules. Source code in trueroll/scoring.py @staticmethod def traditional(frames: list) -> int: \"\"\" Calculate the traditional bowling score from a list of frames. Each frame should be represented by a tuple indicating the number of pins knocked down in each roll. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on traditional bowling rules. \"\"\" score = 0 for i in range(10): frame = frames[i] # Strike if frame[0] == 10: score += 10 if i < 9: next_frame = frames[i + 1] if next_frame[0] == 10: score += 10 if i + 1 < 9: score += frames[i + 2][0] else: score += next_frame[1] else: score += next_frame[0] + next_frame[1] else: score += frame[1] + frame[2] # Spare elif sum(frame) == 10: score += 10 if i < 9: score += frames[i + 1][0] else: score += frame[2] # Open frame else: score += sum(frame) return score Game Class Manages the simulation of a bowling game, providing detailed frame-by-frame results for each bowler. This class supports simulations on specified alleys with distinct characteristics, influencing the gameplay of the bowlers. Attributes: bowlers ( List [ Bowler ] ) \u2013 A list of Bowler objects participating in the game. alley ( Alley ) \u2013 The Alley object specifying the lane type and oil pattern where the game is played. random_seed ( Optional [ int ] ) \u2013 Seed for the random number generator to ensure reproducibility, if provided. Source code in trueroll/game.py class Game: \"\"\" Manages the simulation of a bowling game, providing detailed frame-by-frame results for each bowler. This class supports simulations on specified alleys with distinct characteristics, influencing the gameplay of the bowlers. Attributes: bowlers (List[Bowler]): A list of `Bowler` objects participating in the game. alley (Alley): The `Alley` object specifying the lane type and oil pattern where the game is played. random_seed (Optional[int]): Seed for the random number generator to ensure reproducibility, if provided. \"\"\" def __init__(self, bowlers: List[Bowler], alley: Alley, random_seed: Optional[int] = None): \"\"\" Initialises a game with a list of bowlers and the alley where the game is played. Parameters: bowlers (List[Bowler]): List of Bowler objects participating in the game. alley (Alley): The Alley object specifying the lane type and oil pattern. random_seed (int, optional): Random seed for reproducibility of the simulation. \"\"\" self.bowlers = bowlers self.alley = alley self.random_seed = random_seed def simulate_frame(self, bowler: Bowler, frame_number: int) -> Tuple[int, ...]: \"\"\" Simulates a single frame for a given bowler based on the frame number. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. frame_number (int): The frame number (0-indexed, 0-9). Returns: Tuple[int, ...]: A tuple representing the result of the frame (pins knocked down in each roll). \"\"\" if frame_number < 9: return self.simulate_regular_frame(bowler) else: return self.simulate_last_frame(bowler) def simulate_regular_frame(self, bowler: Bowler) -> Tuple[int, int]: \"\"\" Simulates a regular frame (not the last one), accounting for strikes and open frames. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. Returns: Tuple[int, int]: A tuple of two integers representing the pins knocked down in each roll. \"\"\" strike = np.random.rand() < bowler.strike_prob if strike: return (10, 0) first_roll = np.random.randint(0, 11) second_roll = np.random.randint(0, 11 - first_roll) return (first_roll, second_roll) def simulate_last_frame(self, bowler: Bowler) -> Tuple[int, ...]: \"\"\" Simulates the 10th frame, which may include up to three rolls depending on the bowler's performance. Parameters: bowler (Bowler): The Bowler object for whom the last frame is simulated. Returns: Tuple[int, int, int]: A tuple of up to three integers representing the pins knocked down in each roll. \"\"\" rolls = [] # Simulate the first roll if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) # Simulate the second roll if rolls[0] == 10: # First roll was a strike if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) else: second_roll = np.random.randint(0, 11 - rolls[0]) rolls.append(second_roll) # Simulate the third roll if needed if sum(rolls[:2]) >= 10: # Strike or spare in first two rolls if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) return tuple(rolls[:3]) # Ensure only up to three rolls are returned def frame_by_frame_generator(self) -> Iterator[Dict[str, Tuple[int, ...]]]: \"\"\" A generator to simulate the game frame-by-frame, yielding results for each frame for all bowlers. Yields: Iterator[Dict[str, Tuple[int, ...]]]: An iterator that yields a dictionary representing the frame results of each bowler. \"\"\" for frame_number in range(10): frame_results = {} for bowler in self.bowlers: frame_results[bowler.name] = self.simulate_frame(bowler, frame_number) yield frame_results def simulate_game(self) -> Dict[str, List[Tuple[int, ...]]]: \"\"\" Simulates a complete game for all bowlers, returning the frame-by-frame results. Returns: Dict[str, List[Tuple[int, ...]]]:: A dictionary where keys are bowler names and values are lists of tuples, each tuple representing a frame. \"\"\" if self.random_seed is not None: np.random.seed(self.random_seed) results: Dict[str, List[Tuple[int, ...]]] = {bowler.name: [] for bowler in self.bowlers} for frame_results in self.frame_by_frame_generator(): for name, frame in frame_results.items(): results[name].append(frame) return results __init__(bowlers, alley, random_seed=None) Initialises a game with a list of bowlers and the alley where the game is played. Parameters: bowlers ( List [ Bowler ] ) \u2013 List of Bowler objects participating in the game. alley ( Alley ) \u2013 The Alley object specifying the lane type and oil pattern. random_seed ( int , default: None ) \u2013 Random seed for reproducibility of the simulation. Source code in trueroll/game.py def __init__(self, bowlers: List[Bowler], alley: Alley, random_seed: Optional[int] = None): \"\"\" Initialises a game with a list of bowlers and the alley where the game is played. Parameters: bowlers (List[Bowler]): List of Bowler objects participating in the game. alley (Alley): The Alley object specifying the lane type and oil pattern. random_seed (int, optional): Random seed for reproducibility of the simulation. \"\"\" self.bowlers = bowlers self.alley = alley self.random_seed = random_seed frame_by_frame_generator() A generator to simulate the game frame-by-frame, yielding results for each frame for all bowlers. Yields: Dict [ str , Tuple [ int , ...]] \u2013 Iterator[Dict[str, Tuple[int, ...]]]: An iterator that yields a dictionary representing the frame results of each bowler. Source code in trueroll/game.py def frame_by_frame_generator(self) -> Iterator[Dict[str, Tuple[int, ...]]]: \"\"\" A generator to simulate the game frame-by-frame, yielding results for each frame for all bowlers. Yields: Iterator[Dict[str, Tuple[int, ...]]]: An iterator that yields a dictionary representing the frame results of each bowler. \"\"\" for frame_number in range(10): frame_results = {} for bowler in self.bowlers: frame_results[bowler.name] = self.simulate_frame(bowler, frame_number) yield frame_results simulate_frame(bowler, frame_number) Simulates a single frame for a given bowler based on the frame number. Parameters: bowler ( Bowler ) \u2013 The Bowler object for whom the frame is simulated. frame_number ( int ) \u2013 The frame number (0-indexed, 0-9). Returns: Tuple [ int , ...] \u2013 Tuple[int, ...]: A tuple representing the result of the frame (pins knocked down in each roll). Source code in trueroll/game.py def simulate_frame(self, bowler: Bowler, frame_number: int) -> Tuple[int, ...]: \"\"\" Simulates a single frame for a given bowler based on the frame number. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. frame_number (int): The frame number (0-indexed, 0-9). Returns: Tuple[int, ...]: A tuple representing the result of the frame (pins knocked down in each roll). \"\"\" if frame_number < 9: return self.simulate_regular_frame(bowler) else: return self.simulate_last_frame(bowler) simulate_game() Simulates a complete game for all bowlers, returning the frame-by-frame results. Returns: Dict [ str , List [ Tuple [ int , ...]]] \u2013 Dict[str, List[Tuple[int, ...]]]:: A dictionary where keys are bowler names and values are lists of tuples, each tuple representing a frame. Source code in trueroll/game.py def simulate_game(self) -> Dict[str, List[Tuple[int, ...]]]: \"\"\" Simulates a complete game for all bowlers, returning the frame-by-frame results. Returns: Dict[str, List[Tuple[int, ...]]]:: A dictionary where keys are bowler names and values are lists of tuples, each tuple representing a frame. \"\"\" if self.random_seed is not None: np.random.seed(self.random_seed) results: Dict[str, List[Tuple[int, ...]]] = {bowler.name: [] for bowler in self.bowlers} for frame_results in self.frame_by_frame_generator(): for name, frame in frame_results.items(): results[name].append(frame) return results simulate_last_frame(bowler) Simulates the 10th frame, which may include up to three rolls depending on the bowler's performance. Parameters: bowler ( Bowler ) \u2013 The Bowler object for whom the last frame is simulated. Returns: Tuple [ int , ...] \u2013 Tuple[int, int, int]: A tuple of up to three integers representing the pins knocked down in each roll. Source code in trueroll/game.py def simulate_last_frame(self, bowler: Bowler) -> Tuple[int, ...]: \"\"\" Simulates the 10th frame, which may include up to three rolls depending on the bowler's performance. Parameters: bowler (Bowler): The Bowler object for whom the last frame is simulated. Returns: Tuple[int, int, int]: A tuple of up to three integers representing the pins knocked down in each roll. \"\"\" rolls = [] # Simulate the first roll if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) # Simulate the second roll if rolls[0] == 10: # First roll was a strike if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) else: second_roll = np.random.randint(0, 11 - rolls[0]) rolls.append(second_roll) # Simulate the third roll if needed if sum(rolls[:2]) >= 10: # Strike or spare in first two rolls if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) return tuple(rolls[:3]) # Ensure only up to three rolls are returned simulate_regular_frame(bowler) Simulates a regular frame (not the last one), accounting for strikes and open frames. Parameters: bowler ( Bowler ) \u2013 The Bowler object for whom the frame is simulated. Returns: Tuple [ int , int ] \u2013 Tuple[int, int]: A tuple of two integers representing the pins knocked down in each roll. Source code in trueroll/game.py def simulate_regular_frame(self, bowler: Bowler) -> Tuple[int, int]: \"\"\" Simulates a regular frame (not the last one), accounting for strikes and open frames. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. Returns: Tuple[int, int]: A tuple of two integers representing the pins knocked down in each roll. \"\"\" strike = np.random.rand() < bowler.strike_prob if strike: return (10, 0) first_roll = np.random.randint(0, 11) second_roll = np.random.randint(0, 11 - first_roll) return (first_roll, second_roll) Tournament Class Source code in trueroll/tournament.py class Tournament: def __init__(self, bowlers: List[Bowler], alley: Alley, num_games: int = 1): \"\"\" Initialize a Tournament instance with bowlers, the alley where the tournament is played, and the number of games each bowler will play. Parameters: bowlers (List[Bowler]): A list of `Bowler` objects representing the participants. alley (Alley): The `Alley` object representing the venue of the tournament. num_games (int): The number of games each bowler will play in the tournament. Attributes: results (Dict[str, List[List[int]]]): A dictionary to store results for each bowler. \"\"\" self.bowlers = bowlers self.alley = alley self.num_games = num_games self.results: Dict[str, List[List[Tuple[int, ...]]]] = {bowler.name: [] for bowler in bowlers} # self.results = {bowler.name: [] for bowler in bowlers} def run_tournament(self): \"\"\" Simulate the entire tournament, running the specified number of games for each bowler. \"\"\" for _ in range(self.num_games): game = Game(self.bowlers, self.alley) game_results = game.simulate_game() for name, scores in game_results.items(): self.results[name].append(scores) def get_results(self) -> Dict[str, List[int]]: \"\"\" Calculate and return the total scores for each bowler over the course of the tournament. Returns: Dict[str, List[int]]: A dictionary with bowler names as keys and lists of their total scores for each game as values. \"\"\" total_scores = {name: [sum(sum(frame) for frame in game) for game in games] for name, games in self.results.items()} return total_scores def get_average_scores(self) -> Dict[str, float]: \"\"\" Calculate and return the average scores for each bowler in the tournament. Returns: Dict[str, float]: A dictionary with bowler names as keys and their average score as values. \"\"\" average_scores = {name: sum(scores) / len(scores) if scores else 0 for name, scores in self.get_results().items()} return average_scores __init__(bowlers, alley, num_games=1) Initialize a Tournament instance with bowlers, the alley where the tournament is played, and the number of games each bowler will play. Parameters: bowlers ( List [ Bowler ] ) \u2013 A list of Bowler objects representing the participants. alley ( Alley ) \u2013 The Alley object representing the venue of the tournament. num_games ( int , default: 1 ) \u2013 The number of games each bowler will play in the tournament. Attributes: results ( Dict [ str , List [ List [ int ]]] ) \u2013 A dictionary to store results for each bowler. Source code in trueroll/tournament.py def __init__(self, bowlers: List[Bowler], alley: Alley, num_games: int = 1): \"\"\" Initialize a Tournament instance with bowlers, the alley where the tournament is played, and the number of games each bowler will play. Parameters: bowlers (List[Bowler]): A list of `Bowler` objects representing the participants. alley (Alley): The `Alley` object representing the venue of the tournament. num_games (int): The number of games each bowler will play in the tournament. Attributes: results (Dict[str, List[List[int]]]): A dictionary to store results for each bowler. \"\"\" self.bowlers = bowlers self.alley = alley self.num_games = num_games self.results: Dict[str, List[List[Tuple[int, ...]]]] = {bowler.name: [] for bowler in bowlers} get_average_scores() Calculate and return the average scores for each bowler in the tournament. Returns: Dict [ str , float ] \u2013 Dict[str, float]: A dictionary with bowler names as keys and their average score as values. Source code in trueroll/tournament.py def get_average_scores(self) -> Dict[str, float]: \"\"\" Calculate and return the average scores for each bowler in the tournament. Returns: Dict[str, float]: A dictionary with bowler names as keys and their average score as values. \"\"\" average_scores = {name: sum(scores) / len(scores) if scores else 0 for name, scores in self.get_results().items()} return average_scores get_results() Calculate and return the total scores for each bowler over the course of the tournament. Returns: Dict [ str , List [ int ]] \u2013 Dict[str, List[int]]: A dictionary with bowler names as keys and lists of their total scores for each game as values. Source code in trueroll/tournament.py def get_results(self) -> Dict[str, List[int]]: \"\"\" Calculate and return the total scores for each bowler over the course of the tournament. Returns: Dict[str, List[int]]: A dictionary with bowler names as keys and lists of their total scores for each game as values. \"\"\" total_scores = {name: [sum(sum(frame) for frame in game) for game in games] for name, games in self.results.items()} return total_scores run_tournament() Simulate the entire tournament, running the specified number of games for each bowler. Source code in trueroll/tournament.py def run_tournament(self): \"\"\" Simulate the entire tournament, running the specified number of games for each bowler. \"\"\" for _ in range(self.num_games): game = Game(self.bowlers, self.alley) game_results = game.simulate_game() for name, scores in game_results.items(): self.results[name].append(scores) BowlingDatabase Class Handles the storage and retrieval of bowling simulation data in an SQLite database. Provides methods to add and manage bowlers, alleys, games, and detailed game statistics. Source code in trueroll/bowling_database.py class BowlingDatabase: \"\"\" Handles the storage and retrieval of bowling simulation data in an SQLite database. Provides methods to add and manage bowlers, alleys, games, and detailed game statistics. \"\"\" def __init__(self, db_name: str = 'bowling.db'): \"\"\" Initialises the database connection and creates tables if they do not already exist. Args: db_name (str): The filename of the database. Defaults to 'bowling.db'. \"\"\" self.db_name = db_name self.conn = sqlite3.connect(self.db_name) self.create_tables() def create_tables(self): \"\"\" Creates tables in the database if they do not exist to store bowlers, alleys, games, and game details. \"\"\" c = self.conn.cursor() # Create tables c.execute(''' CREATE TABLE IF NOT EXISTS Bowlers ( BowlerID INTEGER PRIMARY KEY, Name TEXT UNIQUE, Handedness TEXT, Style TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Alleys ( AlleyID INTEGER PRIMARY KEY, Name TEXT, Location TEXT, LaneType TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS OilPatterns ( PatternID INTEGER PRIMARY KEY, Name TEXT, Description TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Games ( GameID INTEGER PRIMARY KEY, Date TEXT, AlleyID INTEGER, OilPatternID INTEGER, FOREIGN KEY (AlleyID) REFERENCES Alleys(AlleyID), FOREIGN KEY (OilPatternID) REFERENCES OilPatterns(PatternID) ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS GameDetails ( GameID INTEGER, BowlerID INTEGER, FrameData TEXT, TotalScore INTEGER, StrikePercentage REAL, SparePercentage REAL, FOREIGN KEY (GameID) REFERENCES Games(GameID), FOREIGN KEY (BowlerID) REFERENCES Bowlers(BowlerID) ) ''') # Commit changes self.conn.commit() def add_bowler(self, bowler: 'Bowler'): \"\"\" Adds a new bowler to the database or updates an existing bowler with the same name. Args: bowler (Bowler): An instance of the Bowler class containing bowler data. Returns: int: The database ID of the added or updated bowler. \"\"\" c = self.conn.cursor() c.execute(''' INSERT INTO Bowlers (Name, Handedness, Style) VALUES (?, ?, ?) ON CONFLICT(Name) DO UPDATE SET Handedness=excluded.Handedness, Style=excluded.Style ''', (bowler.name, bowler.handedness, bowler.technique)) self.conn.commit() return c.lastrowid def add_alley(self, alley: 'Alley'): \"\"\" Adds a new bowling alley to the database. Args: alley (Alley): An instance of the Alley class containing alley data. Returns: int: The database ID of the added alley. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Alleys (Name, Location, LaneType) VALUES (?, ?, ?)', (alley.name, alley.location, alley.lane_type)) self.conn.commit() return c.lastrowid def add_game(self, date: str, alley_id: int, oil_pattern_id: int, frames: List[Tuple[int, ...]]): \"\"\" Adds a new game along with detailed frame data to the database. Args: date (str): The date the game was played. alley_id (int): The database ID of the alley where the game was played. oil_pattern_id (int): The database ID of the oil pattern used in the game. frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Games (Date, AlleyID, OilPatternID) VALUES (?, ?, ?)', (date, alley_id, oil_pattern_id)) game_id = c.lastrowid total_score, strike_percentage, spare_percentage = self.calculate_stats(frames) c.execute(''' INSERT INTO GameDetails (GameID, FrameData, TotalScore, StrikePercentage, SparePercentage) VALUES (?, ?, ?, ?, ?) ''', (game_id, str(frames), total_score, strike_percentage, spare_percentage)) self.conn.commit() def calculate_stats(self, frames: List[Tuple[int, ...]]) -> Tuple[int, float, float]: \"\"\" Calculate total score, strike, and spare percentages from frame data. Args: frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. Returns: Tuple[int, float, float]: A tuple containing the total score, strike percentage, and spare percentage. \"\"\" total_score = 0 # Implement scoring calculation based on rules strikes = sum(1 for frame in frames if frame[0] == 10) spares = sum(1 for frame in frames if sum(frame[:2]) == 10 and frame[0] != 10) total_frames = len(frames) strike_percentage = (strikes / total_frames) * 100 spare_percentage = (spares / total_frames) * 100 return total_score, strike_percentage, spare_percentage def close(self): \"\"\" Closes the database connection. \"\"\" self.conn.close() __init__(db_name='bowling.db') Initialises the database connection and creates tables if they do not already exist. Parameters: db_name ( str , default: 'bowling.db' ) \u2013 The filename of the database. Defaults to 'bowling.db'. Source code in trueroll/bowling_database.py def __init__(self, db_name: str = 'bowling.db'): \"\"\" Initialises the database connection and creates tables if they do not already exist. Args: db_name (str): The filename of the database. Defaults to 'bowling.db'. \"\"\" self.db_name = db_name self.conn = sqlite3.connect(self.db_name) self.create_tables() add_alley(alley) Adds a new bowling alley to the database. Parameters: alley ( Alley ) \u2013 An instance of the Alley class containing alley data. Returns: int \u2013 The database ID of the added alley. Source code in trueroll/bowling_database.py def add_alley(self, alley: 'Alley'): \"\"\" Adds a new bowling alley to the database. Args: alley (Alley): An instance of the Alley class containing alley data. Returns: int: The database ID of the added alley. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Alleys (Name, Location, LaneType) VALUES (?, ?, ?)', (alley.name, alley.location, alley.lane_type)) self.conn.commit() return c.lastrowid add_bowler(bowler) Adds a new bowler to the database or updates an existing bowler with the same name. Parameters: bowler ( Bowler ) \u2013 An instance of the Bowler class containing bowler data. Returns: int \u2013 The database ID of the added or updated bowler. Source code in trueroll/bowling_database.py def add_bowler(self, bowler: 'Bowler'): \"\"\" Adds a new bowler to the database or updates an existing bowler with the same name. Args: bowler (Bowler): An instance of the Bowler class containing bowler data. Returns: int: The database ID of the added or updated bowler. \"\"\" c = self.conn.cursor() c.execute(''' INSERT INTO Bowlers (Name, Handedness, Style) VALUES (?, ?, ?) ON CONFLICT(Name) DO UPDATE SET Handedness=excluded.Handedness, Style=excluded.Style ''', (bowler.name, bowler.handedness, bowler.technique)) self.conn.commit() return c.lastrowid add_game(date, alley_id, oil_pattern_id, frames) Adds a new game along with detailed frame data to the database. Parameters: date ( str ) \u2013 The date the game was played. alley_id ( int ) \u2013 The database ID of the alley where the game was played. oil_pattern_id ( int ) \u2013 The database ID of the oil pattern used in the game. frames ( List [ Tuple [ int , ...]] ) \u2013 A list of tuples representing the frames played in the game. Source code in trueroll/bowling_database.py def add_game(self, date: str, alley_id: int, oil_pattern_id: int, frames: List[Tuple[int, ...]]): \"\"\" Adds a new game along with detailed frame data to the database. Args: date (str): The date the game was played. alley_id (int): The database ID of the alley where the game was played. oil_pattern_id (int): The database ID of the oil pattern used in the game. frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Games (Date, AlleyID, OilPatternID) VALUES (?, ?, ?)', (date, alley_id, oil_pattern_id)) game_id = c.lastrowid total_score, strike_percentage, spare_percentage = self.calculate_stats(frames) c.execute(''' INSERT INTO GameDetails (GameID, FrameData, TotalScore, StrikePercentage, SparePercentage) VALUES (?, ?, ?, ?, ?) ''', (game_id, str(frames), total_score, strike_percentage, spare_percentage)) self.conn.commit() calculate_stats(frames) Calculate total score, strike, and spare percentages from frame data. Parameters: frames ( List [ Tuple [ int , ...]] ) \u2013 A list of tuples representing the frames played in the game. Returns: Tuple [ int , float , float ] \u2013 Tuple[int, float, float]: A tuple containing the total score, strike percentage, and spare percentage. Source code in trueroll/bowling_database.py def calculate_stats(self, frames: List[Tuple[int, ...]]) -> Tuple[int, float, float]: \"\"\" Calculate total score, strike, and spare percentages from frame data. Args: frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. Returns: Tuple[int, float, float]: A tuple containing the total score, strike percentage, and spare percentage. \"\"\" total_score = 0 # Implement scoring calculation based on rules strikes = sum(1 for frame in frames if frame[0] == 10) spares = sum(1 for frame in frames if sum(frame[:2]) == 10 and frame[0] != 10) total_frames = len(frames) strike_percentage = (strikes / total_frames) * 100 spare_percentage = (spares / total_frames) * 100 return total_score, strike_percentage, spare_percentage close() Closes the database connection. Source code in trueroll/bowling_database.py def close(self): \"\"\" Closes the database connection. \"\"\" self.conn.close() create_tables() Creates tables in the database if they do not exist to store bowlers, alleys, games, and game details. Source code in trueroll/bowling_database.py def create_tables(self): \"\"\" Creates tables in the database if they do not exist to store bowlers, alleys, games, and game details. \"\"\" c = self.conn.cursor() # Create tables c.execute(''' CREATE TABLE IF NOT EXISTS Bowlers ( BowlerID INTEGER PRIMARY KEY, Name TEXT UNIQUE, Handedness TEXT, Style TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Alleys ( AlleyID INTEGER PRIMARY KEY, Name TEXT, Location TEXT, LaneType TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS OilPatterns ( PatternID INTEGER PRIMARY KEY, Name TEXT, Description TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Games ( GameID INTEGER PRIMARY KEY, Date TEXT, AlleyID INTEGER, OilPatternID INTEGER, FOREIGN KEY (AlleyID) REFERENCES Alleys(AlleyID), FOREIGN KEY (OilPatternID) REFERENCES OilPatterns(PatternID) ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS GameDetails ( GameID INTEGER, BowlerID INTEGER, FrameData TEXT, TotalScore INTEGER, StrikePercentage REAL, SparePercentage REAL, FOREIGN KEY (GameID) REFERENCES Games(GameID), FOREIGN KEY (BowlerID) REFERENCES Bowlers(BowlerID) ) ''') # Commit changes self.conn.commit() League Class Source code in trueroll/league.py class League: def __init__(self, name: str, alley: Alley, oil_pattern: str, team_size: int, num_games_per_night: int, season_length: int): \"\"\" Initialises a league with specified parameters, setting up the environment where the league games are played, the type of oil pattern used, the team size, the number of games per league night, and the duration of the season. Args: name (str): The name of the league. alley (Alley): An Alley object where the league games are held. oil_pattern (str): The oil pattern used on the lanes throughout the season. team_size (int): The number of bowlers in each team. num_games_per_night (int): The number of games played each league night. season_length (int): The number of weeks the league runs. Attributes: teams (List[List[Bowler]]): Stores the teams participating in the league. \"\"\" self.name = name self.alley = alley self.oil_pattern = oil_pattern self.team_size = team_size self.num_games_per_night = num_games_per_night self.season_length = season_length self.teams: List[List[Bowler]] = [] # self.teams = [] # List of teams, each team is a list of Bowler objects def add_team(self, team: List[Bowler]): \"\"\" Adds a team to the league. Ensures the team size matches the league's required team size. Args: team (List[Bowler]): A list of Bowler objects making up the team. Raises: ValueError: If the number of bowlers in the team does not match the league's specified team size. \"\"\" if len(team) != self.team_size: raise ValueError(\"Team size must match the league's specified team size\") self.teams.append(team) def run_season(self): \"\"\" Simulates the entire season of the league, organising games per night for each team over the specified season length. Returns: Dict[str, List[Dict[str, float]]]: A dictionary with team names as keys and a list of their average scores per night as values. \"\"\" results = {f\"Team {i+1}\": [] for i in range(len(self.teams))} for week in range(self.season_length): for i, team in enumerate(self.teams): tournament = Tournament(team, self.alley, self.num_games_per_night) tournament.run_tournament() results[f\"Team {i+1}\"].append(tournament.get_average_scores()) return results __init__(name, alley, oil_pattern, team_size, num_games_per_night, season_length) Initialises a league with specified parameters, setting up the environment where the league games are played, the type of oil pattern used, the team size, the number of games per league night, and the duration of the season. Parameters: name ( str ) \u2013 The name of the league. alley ( Alley ) \u2013 An Alley object where the league games are held. oil_pattern ( str ) \u2013 The oil pattern used on the lanes throughout the season. team_size ( int ) \u2013 The number of bowlers in each team. num_games_per_night ( int ) \u2013 The number of games played each league night. season_length ( int ) \u2013 The number of weeks the league runs. Attributes: teams ( List [ List [ Bowler ]] ) \u2013 Stores the teams participating in the league. Source code in trueroll/league.py def __init__(self, name: str, alley: Alley, oil_pattern: str, team_size: int, num_games_per_night: int, season_length: int): \"\"\" Initialises a league with specified parameters, setting up the environment where the league games are played, the type of oil pattern used, the team size, the number of games per league night, and the duration of the season. Args: name (str): The name of the league. alley (Alley): An Alley object where the league games are held. oil_pattern (str): The oil pattern used on the lanes throughout the season. team_size (int): The number of bowlers in each team. num_games_per_night (int): The number of games played each league night. season_length (int): The number of weeks the league runs. Attributes: teams (List[List[Bowler]]): Stores the teams participating in the league. \"\"\" self.name = name self.alley = alley self.oil_pattern = oil_pattern self.team_size = team_size self.num_games_per_night = num_games_per_night self.season_length = season_length self.teams: List[List[Bowler]] = [] add_team(team) Adds a team to the league. Ensures the team size matches the league's required team size. Parameters: team ( List [ Bowler ] ) \u2013 A list of Bowler objects making up the team. Raises: ValueError \u2013 If the number of bowlers in the team does not match the league's specified team size. Source code in trueroll/league.py def add_team(self, team: List[Bowler]): \"\"\" Adds a team to the league. Ensures the team size matches the league's required team size. Args: team (List[Bowler]): A list of Bowler objects making up the team. Raises: ValueError: If the number of bowlers in the team does not match the league's specified team size. \"\"\" if len(team) != self.team_size: raise ValueError(\"Team size must match the league's specified team size\") self.teams.append(team) run_season() Simulates the entire season of the league, organising games per night for each team over the specified season length. Returns: \u2013 Dict[str, List[Dict[str, float]]]: A dictionary with team names as keys and a list of their average scores per night as values. Source code in trueroll/league.py def run_season(self): \"\"\" Simulates the entire season of the league, organising games per night for each team over the specified season length. Returns: Dict[str, List[Dict[str, float]]]: A dictionary with team names as keys and a list of their average scores per night as values. \"\"\" results = {f\"Team {i+1}\": [] for i in range(len(self.teams))} for week in range(self.season_length): for i, team in enumerate(self.teams): tournament = Tournament(team, self.alley, self.num_games_per_night) tournament.run_tournament() results[f\"Team {i+1}\"].append(tournament.get_average_scores()) return results","title":"API Documentation"},{"location":"api/#alley-class","text":"Represents a bowling alley where games are played, including details about the lane conditions. Attributes: name ( str ) \u2013 The name of the alley. location ( str ) \u2013 The geographic location of the alley. lane_type ( str ) \u2013 The type of lane surface, such as 'Wood' or 'Synthetic'. Source code in trueroll/alley.py class Alley: \"\"\" Represents a bowling alley where games are played, including details about the lane conditions. Attributes: name (str): The name of the alley. location (str): The geographic location of the alley. lane_type (str): The type of lane surface, such as 'Wood' or 'Synthetic'. \"\"\" VALID_LANE_TYPES = {'wood', 'synthetic'} def __init__(self, name: str, location: str, lane_type: str): \"\"\" Initialize a new Alley instance. Parameters: name (str): The name of the alley. location (str): The geographic location of the alley. lane_type (str): The type of lane surface, indicating the material of the bowling lane. Raises: ValueError: If lane_type is not 'Wood' or 'Synthetic'. \"\"\" self.name = name self.location = location if lane_type.lower() not in self.VALID_LANE_TYPES: raise ValueError(f\"Invalid lane type '{lane_type}'. Valid types are: 'Wood', 'Synthetic'\") self.lane_type = lane_type.capitalize() def __str__(self): \"\"\" Return a string representation of the Alley instance, which is helpful for debugging and logging. Returns: str: A string that represents this Alley. \"\"\" return f\"{self.name} - {self.location} ({self.lane_type})\"","title":"Alley Class"},{"location":"api/#trueroll.alley.Alley.__init__","text":"Initialize a new Alley instance. Parameters: name ( str ) \u2013 The name of the alley. location ( str ) \u2013 The geographic location of the alley. lane_type ( str ) \u2013 The type of lane surface, indicating the material of the bowling lane. Raises: ValueError \u2013 If lane_type is not 'Wood' or 'Synthetic'. Source code in trueroll/alley.py def __init__(self, name: str, location: str, lane_type: str): \"\"\" Initialize a new Alley instance. Parameters: name (str): The name of the alley. location (str): The geographic location of the alley. lane_type (str): The type of lane surface, indicating the material of the bowling lane. Raises: ValueError: If lane_type is not 'Wood' or 'Synthetic'. \"\"\" self.name = name self.location = location if lane_type.lower() not in self.VALID_LANE_TYPES: raise ValueError(f\"Invalid lane type '{lane_type}'. Valid types are: 'Wood', 'Synthetic'\") self.lane_type = lane_type.capitalize()","title":"__init__"},{"location":"api/#trueroll.alley.Alley.__str__","text":"Return a string representation of the Alley instance, which is helpful for debugging and logging. Returns: str \u2013 A string that represents this Alley. Source code in trueroll/alley.py def __str__(self): \"\"\" Return a string representation of the Alley instance, which is helpful for debugging and logging. Returns: str: A string that represents this Alley. \"\"\" return f\"{self.name} - {self.location} ({self.lane_type})\"","title":"__str__"},{"location":"api/#bowler-class","text":"Represents a bowler in a bowling simulation, including probabilities for striking and sparing, as well as personal characteristics like handedness and bowling technique. Attributes: name ( str ) \u2013 The name of the bowler. strike_prob ( float ) \u2013 Probability of hitting a strike. spare_prob ( float ) \u2013 Probability of hitting a spare. handedness ( str ) \u2013 The preferred hand of the bowler, either 'left' or 'right'. technique ( str ) \u2013 The bowling technique used, either 'single' or 'double' handed. Source code in trueroll/bowler.py class Bowler: \"\"\" Represents a bowler in a bowling simulation, including probabilities for striking and sparing, as well as personal characteristics like handedness and bowling technique. Attributes: name (str): The name of the bowler. strike_prob (float): Probability of hitting a strike. spare_prob (float): Probability of hitting a spare. handedness (str): The preferred hand of the bowler, either 'left' or 'right'. technique (str): The bowling technique used, either 'single' or 'double' handed. \"\"\" def __init__(self, name: str, strike_prob: float, spare_prob: float, handedness: str = 'right', technique: str = 'single'): \"\"\" Initializes a new instance of Bowler. Parameters: name (str): The name of the bowler. strike_prob (float): Probability of hitting a strike, between 0 and 1. spare_prob (float): Probability of hitting a spare, between 0 and 1. handedness (str): The preferred hand of the bowler, either 'left' or 'right' (default 'right'). technique (str): The bowling technique used by the bowler, either 'single' or 'double' handed (default 'single'). Raises: ValueError: If strike_prob or spare_prob is greater than 1. \"\"\" if not (0 <= strike_prob <= 1): raise ValueError(f\"Invalid strike probability {strike_prob}. Must be between 0 and 1.\") if not (0 <= spare_prob <= 1): raise ValueError(f\"Invalid spare probability {spare_prob}. Must be between 0 and 1.\") if handedness not in ['left', 'right']: raise ValueError(f\"Invalid handedness '{handedness}'. Must be 'left' or 'right'.\") if technique not in ['single', 'double']: raise ValueError(f\"Invalid technique '{technique}'. Must be 'single' or 'double'.\") self.name = name self.strike_prob = strike_prob self.spare_prob = spare_prob self.handedness = handedness self.technique = technique def __str__(self): \"\"\" Returns a string representation of the Bowler instance. Returns: str: A string that includes all the attributes of the Bowler. \"\"\" return (f\"Bowler(Name: {self.name}, Strike Probability: {self.strike_prob}, \" f\"Spare Probability: {self.spare_prob}, Handedness: {self.handedness}, \" f\"Technique: {self.technique})\")","title":"Bowler Class"},{"location":"api/#trueroll.bowler.Bowler.__init__","text":"Initializes a new instance of Bowler. Parameters: name ( str ) \u2013 The name of the bowler. strike_prob ( float ) \u2013 Probability of hitting a strike, between 0 and 1. spare_prob ( float ) \u2013 Probability of hitting a spare, between 0 and 1. handedness ( str , default: 'right' ) \u2013 The preferred hand of the bowler, either 'left' or 'right' (default 'right'). technique ( str , default: 'single' ) \u2013 The bowling technique used by the bowler, either 'single' or 'double' handed (default 'single'). Raises: ValueError \u2013 If strike_prob or spare_prob is greater than 1. Source code in trueroll/bowler.py def __init__(self, name: str, strike_prob: float, spare_prob: float, handedness: str = 'right', technique: str = 'single'): \"\"\" Initializes a new instance of Bowler. Parameters: name (str): The name of the bowler. strike_prob (float): Probability of hitting a strike, between 0 and 1. spare_prob (float): Probability of hitting a spare, between 0 and 1. handedness (str): The preferred hand of the bowler, either 'left' or 'right' (default 'right'). technique (str): The bowling technique used by the bowler, either 'single' or 'double' handed (default 'single'). Raises: ValueError: If strike_prob or spare_prob is greater than 1. \"\"\" if not (0 <= strike_prob <= 1): raise ValueError(f\"Invalid strike probability {strike_prob}. Must be between 0 and 1.\") if not (0 <= spare_prob <= 1): raise ValueError(f\"Invalid spare probability {spare_prob}. Must be between 0 and 1.\") if handedness not in ['left', 'right']: raise ValueError(f\"Invalid handedness '{handedness}'. Must be 'left' or 'right'.\") if technique not in ['single', 'double']: raise ValueError(f\"Invalid technique '{technique}'. Must be 'single' or 'double'.\") self.name = name self.strike_prob = strike_prob self.spare_prob = spare_prob self.handedness = handedness self.technique = technique","title":"__init__"},{"location":"api/#trueroll.bowler.Bowler.__str__","text":"Returns a string representation of the Bowler instance. Returns: str \u2013 A string that includes all the attributes of the Bowler. Source code in trueroll/bowler.py def __str__(self): \"\"\" Returns a string representation of the Bowler instance. Returns: str: A string that includes all the attributes of the Bowler. \"\"\" return (f\"Bowler(Name: {self.name}, Strike Probability: {self.strike_prob}, \" f\"Spare Probability: {self.spare_prob}, Handedness: {self.handedness}, \" f\"Technique: {self.technique})\")","title":"__str__"},{"location":"api/#scoring-class","text":"Source code in trueroll/scoring.py class Scoring: @staticmethod def traditional(frames: list) -> int: \"\"\" Calculate the traditional bowling score from a list of frames. Each frame should be represented by a tuple indicating the number of pins knocked down in each roll. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on traditional bowling rules. \"\"\" score = 0 for i in range(10): frame = frames[i] # Strike if frame[0] == 10: score += 10 if i < 9: next_frame = frames[i + 1] if next_frame[0] == 10: score += 10 if i + 1 < 9: score += frames[i + 2][0] else: score += next_frame[1] else: score += next_frame[0] + next_frame[1] else: score += frame[1] + frame[2] # Spare elif sum(frame) == 10: score += 10 if i < 9: score += frames[i + 1][0] else: score += frame[2] # Open frame else: score += sum(frame) return score @staticmethod def current_frame(frames: list) -> int: \"\"\" Calculate the score using current frame scoring rules, also known as World Bowling scoring. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on current frame (World Bowling) rules. \"\"\" score = 0 for frame in frames: if frame[0] == 10: # Strike score += 30 elif sum(frame) == 10: # Spare score += 10 + frame[0] else: score += sum(frame) return score @staticmethod def nine_pin_no_tap(frames: list) -> int: \"\"\" Calculate the score for a 9-pin no-tap game, where knocking down 9 pins counts as a strike. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on 9-pin no-tap rules. \"\"\" score = 0 for i, frame in enumerate(frames): first_roll = frame[0] if first_roll == 9 or first_roll == 10: if i < 9: # Not the last frame next_frame = frames[i + 1] score += 10 + next_frame[0] + (next_frame[1] if len(next_frame) > 1 else 0) else: # Last frame score += 10 + frame[1] + frame[2] elif sum(frame[:2]) == 10: # Spare score += 10 + (frames[i + 1][0] if i < 9 else frame[2]) else: score += sum(frame) return score","title":"Scoring Class"},{"location":"api/#trueroll.scoring.Scoring.current_frame","text":"Calculate the score using current frame scoring rules, also known as World Bowling scoring. Parameters: frames ( list ) \u2013 A list of tuples representing the game frames. Returns: int ( int ) \u2013 The total score calculated based on current frame (World Bowling) rules. Source code in trueroll/scoring.py @staticmethod def current_frame(frames: list) -> int: \"\"\" Calculate the score using current frame scoring rules, also known as World Bowling scoring. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on current frame (World Bowling) rules. \"\"\" score = 0 for frame in frames: if frame[0] == 10: # Strike score += 30 elif sum(frame) == 10: # Spare score += 10 + frame[0] else: score += sum(frame) return score","title":"current_frame"},{"location":"api/#trueroll.scoring.Scoring.nine_pin_no_tap","text":"Calculate the score for a 9-pin no-tap game, where knocking down 9 pins counts as a strike. Parameters: frames ( list ) \u2013 A list of tuples representing the game frames. Returns: int ( int ) \u2013 The total score calculated based on 9-pin no-tap rules. Source code in trueroll/scoring.py @staticmethod def nine_pin_no_tap(frames: list) -> int: \"\"\" Calculate the score for a 9-pin no-tap game, where knocking down 9 pins counts as a strike. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on 9-pin no-tap rules. \"\"\" score = 0 for i, frame in enumerate(frames): first_roll = frame[0] if first_roll == 9 or first_roll == 10: if i < 9: # Not the last frame next_frame = frames[i + 1] score += 10 + next_frame[0] + (next_frame[1] if len(next_frame) > 1 else 0) else: # Last frame score += 10 + frame[1] + frame[2] elif sum(frame[:2]) == 10: # Spare score += 10 + (frames[i + 1][0] if i < 9 else frame[2]) else: score += sum(frame) return score","title":"nine_pin_no_tap"},{"location":"api/#trueroll.scoring.Scoring.traditional","text":"Calculate the traditional bowling score from a list of frames. Each frame should be represented by a tuple indicating the number of pins knocked down in each roll. Parameters: frames ( list ) \u2013 A list of tuples representing the game frames. Returns: int ( int ) \u2013 The total score calculated based on traditional bowling rules. Source code in trueroll/scoring.py @staticmethod def traditional(frames: list) -> int: \"\"\" Calculate the traditional bowling score from a list of frames. Each frame should be represented by a tuple indicating the number of pins knocked down in each roll. Parameters: frames (list): A list of tuples representing the game frames. Returns: int: The total score calculated based on traditional bowling rules. \"\"\" score = 0 for i in range(10): frame = frames[i] # Strike if frame[0] == 10: score += 10 if i < 9: next_frame = frames[i + 1] if next_frame[0] == 10: score += 10 if i + 1 < 9: score += frames[i + 2][0] else: score += next_frame[1] else: score += next_frame[0] + next_frame[1] else: score += frame[1] + frame[2] # Spare elif sum(frame) == 10: score += 10 if i < 9: score += frames[i + 1][0] else: score += frame[2] # Open frame else: score += sum(frame) return score","title":"traditional"},{"location":"api/#game-class","text":"Manages the simulation of a bowling game, providing detailed frame-by-frame results for each bowler. This class supports simulations on specified alleys with distinct characteristics, influencing the gameplay of the bowlers. Attributes: bowlers ( List [ Bowler ] ) \u2013 A list of Bowler objects participating in the game. alley ( Alley ) \u2013 The Alley object specifying the lane type and oil pattern where the game is played. random_seed ( Optional [ int ] ) \u2013 Seed for the random number generator to ensure reproducibility, if provided. Source code in trueroll/game.py class Game: \"\"\" Manages the simulation of a bowling game, providing detailed frame-by-frame results for each bowler. This class supports simulations on specified alleys with distinct characteristics, influencing the gameplay of the bowlers. Attributes: bowlers (List[Bowler]): A list of `Bowler` objects participating in the game. alley (Alley): The `Alley` object specifying the lane type and oil pattern where the game is played. random_seed (Optional[int]): Seed for the random number generator to ensure reproducibility, if provided. \"\"\" def __init__(self, bowlers: List[Bowler], alley: Alley, random_seed: Optional[int] = None): \"\"\" Initialises a game with a list of bowlers and the alley where the game is played. Parameters: bowlers (List[Bowler]): List of Bowler objects participating in the game. alley (Alley): The Alley object specifying the lane type and oil pattern. random_seed (int, optional): Random seed for reproducibility of the simulation. \"\"\" self.bowlers = bowlers self.alley = alley self.random_seed = random_seed def simulate_frame(self, bowler: Bowler, frame_number: int) -> Tuple[int, ...]: \"\"\" Simulates a single frame for a given bowler based on the frame number. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. frame_number (int): The frame number (0-indexed, 0-9). Returns: Tuple[int, ...]: A tuple representing the result of the frame (pins knocked down in each roll). \"\"\" if frame_number < 9: return self.simulate_regular_frame(bowler) else: return self.simulate_last_frame(bowler) def simulate_regular_frame(self, bowler: Bowler) -> Tuple[int, int]: \"\"\" Simulates a regular frame (not the last one), accounting for strikes and open frames. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. Returns: Tuple[int, int]: A tuple of two integers representing the pins knocked down in each roll. \"\"\" strike = np.random.rand() < bowler.strike_prob if strike: return (10, 0) first_roll = np.random.randint(0, 11) second_roll = np.random.randint(0, 11 - first_roll) return (first_roll, second_roll) def simulate_last_frame(self, bowler: Bowler) -> Tuple[int, ...]: \"\"\" Simulates the 10th frame, which may include up to three rolls depending on the bowler's performance. Parameters: bowler (Bowler): The Bowler object for whom the last frame is simulated. Returns: Tuple[int, int, int]: A tuple of up to three integers representing the pins knocked down in each roll. \"\"\" rolls = [] # Simulate the first roll if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) # Simulate the second roll if rolls[0] == 10: # First roll was a strike if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) else: second_roll = np.random.randint(0, 11 - rolls[0]) rolls.append(second_roll) # Simulate the third roll if needed if sum(rolls[:2]) >= 10: # Strike or spare in first two rolls if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) return tuple(rolls[:3]) # Ensure only up to three rolls are returned def frame_by_frame_generator(self) -> Iterator[Dict[str, Tuple[int, ...]]]: \"\"\" A generator to simulate the game frame-by-frame, yielding results for each frame for all bowlers. Yields: Iterator[Dict[str, Tuple[int, ...]]]: An iterator that yields a dictionary representing the frame results of each bowler. \"\"\" for frame_number in range(10): frame_results = {} for bowler in self.bowlers: frame_results[bowler.name] = self.simulate_frame(bowler, frame_number) yield frame_results def simulate_game(self) -> Dict[str, List[Tuple[int, ...]]]: \"\"\" Simulates a complete game for all bowlers, returning the frame-by-frame results. Returns: Dict[str, List[Tuple[int, ...]]]:: A dictionary where keys are bowler names and values are lists of tuples, each tuple representing a frame. \"\"\" if self.random_seed is not None: np.random.seed(self.random_seed) results: Dict[str, List[Tuple[int, ...]]] = {bowler.name: [] for bowler in self.bowlers} for frame_results in self.frame_by_frame_generator(): for name, frame in frame_results.items(): results[name].append(frame) return results","title":"Game Class"},{"location":"api/#trueroll.game.Game.__init__","text":"Initialises a game with a list of bowlers and the alley where the game is played. Parameters: bowlers ( List [ Bowler ] ) \u2013 List of Bowler objects participating in the game. alley ( Alley ) \u2013 The Alley object specifying the lane type and oil pattern. random_seed ( int , default: None ) \u2013 Random seed for reproducibility of the simulation. Source code in trueroll/game.py def __init__(self, bowlers: List[Bowler], alley: Alley, random_seed: Optional[int] = None): \"\"\" Initialises a game with a list of bowlers and the alley where the game is played. Parameters: bowlers (List[Bowler]): List of Bowler objects participating in the game. alley (Alley): The Alley object specifying the lane type and oil pattern. random_seed (int, optional): Random seed for reproducibility of the simulation. \"\"\" self.bowlers = bowlers self.alley = alley self.random_seed = random_seed","title":"__init__"},{"location":"api/#trueroll.game.Game.frame_by_frame_generator","text":"A generator to simulate the game frame-by-frame, yielding results for each frame for all bowlers. Yields: Dict [ str , Tuple [ int , ...]] \u2013 Iterator[Dict[str, Tuple[int, ...]]]: An iterator that yields a dictionary representing the frame results of each bowler. Source code in trueroll/game.py def frame_by_frame_generator(self) -> Iterator[Dict[str, Tuple[int, ...]]]: \"\"\" A generator to simulate the game frame-by-frame, yielding results for each frame for all bowlers. Yields: Iterator[Dict[str, Tuple[int, ...]]]: An iterator that yields a dictionary representing the frame results of each bowler. \"\"\" for frame_number in range(10): frame_results = {} for bowler in self.bowlers: frame_results[bowler.name] = self.simulate_frame(bowler, frame_number) yield frame_results","title":"frame_by_frame_generator"},{"location":"api/#trueroll.game.Game.simulate_frame","text":"Simulates a single frame for a given bowler based on the frame number. Parameters: bowler ( Bowler ) \u2013 The Bowler object for whom the frame is simulated. frame_number ( int ) \u2013 The frame number (0-indexed, 0-9). Returns: Tuple [ int , ...] \u2013 Tuple[int, ...]: A tuple representing the result of the frame (pins knocked down in each roll). Source code in trueroll/game.py def simulate_frame(self, bowler: Bowler, frame_number: int) -> Tuple[int, ...]: \"\"\" Simulates a single frame for a given bowler based on the frame number. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. frame_number (int): The frame number (0-indexed, 0-9). Returns: Tuple[int, ...]: A tuple representing the result of the frame (pins knocked down in each roll). \"\"\" if frame_number < 9: return self.simulate_regular_frame(bowler) else: return self.simulate_last_frame(bowler)","title":"simulate_frame"},{"location":"api/#trueroll.game.Game.simulate_game","text":"Simulates a complete game for all bowlers, returning the frame-by-frame results. Returns: Dict [ str , List [ Tuple [ int , ...]]] \u2013 Dict[str, List[Tuple[int, ...]]]:: A dictionary where keys are bowler names and values are lists of tuples, each tuple representing a frame. Source code in trueroll/game.py def simulate_game(self) -> Dict[str, List[Tuple[int, ...]]]: \"\"\" Simulates a complete game for all bowlers, returning the frame-by-frame results. Returns: Dict[str, List[Tuple[int, ...]]]:: A dictionary where keys are bowler names and values are lists of tuples, each tuple representing a frame. \"\"\" if self.random_seed is not None: np.random.seed(self.random_seed) results: Dict[str, List[Tuple[int, ...]]] = {bowler.name: [] for bowler in self.bowlers} for frame_results in self.frame_by_frame_generator(): for name, frame in frame_results.items(): results[name].append(frame) return results","title":"simulate_game"},{"location":"api/#trueroll.game.Game.simulate_last_frame","text":"Simulates the 10th frame, which may include up to three rolls depending on the bowler's performance. Parameters: bowler ( Bowler ) \u2013 The Bowler object for whom the last frame is simulated. Returns: Tuple [ int , ...] \u2013 Tuple[int, int, int]: A tuple of up to three integers representing the pins knocked down in each roll. Source code in trueroll/game.py def simulate_last_frame(self, bowler: Bowler) -> Tuple[int, ...]: \"\"\" Simulates the 10th frame, which may include up to three rolls depending on the bowler's performance. Parameters: bowler (Bowler): The Bowler object for whom the last frame is simulated. Returns: Tuple[int, int, int]: A tuple of up to three integers representing the pins knocked down in each roll. \"\"\" rolls = [] # Simulate the first roll if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) # Simulate the second roll if rolls[0] == 10: # First roll was a strike if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) else: second_roll = np.random.randint(0, 11 - rolls[0]) rolls.append(second_roll) # Simulate the third roll if needed if sum(rolls[:2]) >= 10: # Strike or spare in first two rolls if np.random.rand() < bowler.strike_prob: rolls.append(10) else: rolls.append(np.random.randint(0, 11)) return tuple(rolls[:3]) # Ensure only up to three rolls are returned","title":"simulate_last_frame"},{"location":"api/#trueroll.game.Game.simulate_regular_frame","text":"Simulates a regular frame (not the last one), accounting for strikes and open frames. Parameters: bowler ( Bowler ) \u2013 The Bowler object for whom the frame is simulated. Returns: Tuple [ int , int ] \u2013 Tuple[int, int]: A tuple of two integers representing the pins knocked down in each roll. Source code in trueroll/game.py def simulate_regular_frame(self, bowler: Bowler) -> Tuple[int, int]: \"\"\" Simulates a regular frame (not the last one), accounting for strikes and open frames. Parameters: bowler (Bowler): The Bowler object for whom the frame is simulated. Returns: Tuple[int, int]: A tuple of two integers representing the pins knocked down in each roll. \"\"\" strike = np.random.rand() < bowler.strike_prob if strike: return (10, 0) first_roll = np.random.randint(0, 11) second_roll = np.random.randint(0, 11 - first_roll) return (first_roll, second_roll)","title":"simulate_regular_frame"},{"location":"api/#tournament-class","text":"Source code in trueroll/tournament.py class Tournament: def __init__(self, bowlers: List[Bowler], alley: Alley, num_games: int = 1): \"\"\" Initialize a Tournament instance with bowlers, the alley where the tournament is played, and the number of games each bowler will play. Parameters: bowlers (List[Bowler]): A list of `Bowler` objects representing the participants. alley (Alley): The `Alley` object representing the venue of the tournament. num_games (int): The number of games each bowler will play in the tournament. Attributes: results (Dict[str, List[List[int]]]): A dictionary to store results for each bowler. \"\"\" self.bowlers = bowlers self.alley = alley self.num_games = num_games self.results: Dict[str, List[List[Tuple[int, ...]]]] = {bowler.name: [] for bowler in bowlers} # self.results = {bowler.name: [] for bowler in bowlers} def run_tournament(self): \"\"\" Simulate the entire tournament, running the specified number of games for each bowler. \"\"\" for _ in range(self.num_games): game = Game(self.bowlers, self.alley) game_results = game.simulate_game() for name, scores in game_results.items(): self.results[name].append(scores) def get_results(self) -> Dict[str, List[int]]: \"\"\" Calculate and return the total scores for each bowler over the course of the tournament. Returns: Dict[str, List[int]]: A dictionary with bowler names as keys and lists of their total scores for each game as values. \"\"\" total_scores = {name: [sum(sum(frame) for frame in game) for game in games] for name, games in self.results.items()} return total_scores def get_average_scores(self) -> Dict[str, float]: \"\"\" Calculate and return the average scores for each bowler in the tournament. Returns: Dict[str, float]: A dictionary with bowler names as keys and their average score as values. \"\"\" average_scores = {name: sum(scores) / len(scores) if scores else 0 for name, scores in self.get_results().items()} return average_scores","title":"Tournament Class"},{"location":"api/#trueroll.tournament.Tournament.__init__","text":"Initialize a Tournament instance with bowlers, the alley where the tournament is played, and the number of games each bowler will play. Parameters: bowlers ( List [ Bowler ] ) \u2013 A list of Bowler objects representing the participants. alley ( Alley ) \u2013 The Alley object representing the venue of the tournament. num_games ( int , default: 1 ) \u2013 The number of games each bowler will play in the tournament. Attributes: results ( Dict [ str , List [ List [ int ]]] ) \u2013 A dictionary to store results for each bowler. Source code in trueroll/tournament.py def __init__(self, bowlers: List[Bowler], alley: Alley, num_games: int = 1): \"\"\" Initialize a Tournament instance with bowlers, the alley where the tournament is played, and the number of games each bowler will play. Parameters: bowlers (List[Bowler]): A list of `Bowler` objects representing the participants. alley (Alley): The `Alley` object representing the venue of the tournament. num_games (int): The number of games each bowler will play in the tournament. Attributes: results (Dict[str, List[List[int]]]): A dictionary to store results for each bowler. \"\"\" self.bowlers = bowlers self.alley = alley self.num_games = num_games self.results: Dict[str, List[List[Tuple[int, ...]]]] = {bowler.name: [] for bowler in bowlers}","title":"__init__"},{"location":"api/#trueroll.tournament.Tournament.get_average_scores","text":"Calculate and return the average scores for each bowler in the tournament. Returns: Dict [ str , float ] \u2013 Dict[str, float]: A dictionary with bowler names as keys and their average score as values. Source code in trueroll/tournament.py def get_average_scores(self) -> Dict[str, float]: \"\"\" Calculate and return the average scores for each bowler in the tournament. Returns: Dict[str, float]: A dictionary with bowler names as keys and their average score as values. \"\"\" average_scores = {name: sum(scores) / len(scores) if scores else 0 for name, scores in self.get_results().items()} return average_scores","title":"get_average_scores"},{"location":"api/#trueroll.tournament.Tournament.get_results","text":"Calculate and return the total scores for each bowler over the course of the tournament. Returns: Dict [ str , List [ int ]] \u2013 Dict[str, List[int]]: A dictionary with bowler names as keys and lists of their total scores for each game as values. Source code in trueroll/tournament.py def get_results(self) -> Dict[str, List[int]]: \"\"\" Calculate and return the total scores for each bowler over the course of the tournament. Returns: Dict[str, List[int]]: A dictionary with bowler names as keys and lists of their total scores for each game as values. \"\"\" total_scores = {name: [sum(sum(frame) for frame in game) for game in games] for name, games in self.results.items()} return total_scores","title":"get_results"},{"location":"api/#trueroll.tournament.Tournament.run_tournament","text":"Simulate the entire tournament, running the specified number of games for each bowler. Source code in trueroll/tournament.py def run_tournament(self): \"\"\" Simulate the entire tournament, running the specified number of games for each bowler. \"\"\" for _ in range(self.num_games): game = Game(self.bowlers, self.alley) game_results = game.simulate_game() for name, scores in game_results.items(): self.results[name].append(scores)","title":"run_tournament"},{"location":"api/#bowlingdatabase-class","text":"Handles the storage and retrieval of bowling simulation data in an SQLite database. Provides methods to add and manage bowlers, alleys, games, and detailed game statistics. Source code in trueroll/bowling_database.py class BowlingDatabase: \"\"\" Handles the storage and retrieval of bowling simulation data in an SQLite database. Provides methods to add and manage bowlers, alleys, games, and detailed game statistics. \"\"\" def __init__(self, db_name: str = 'bowling.db'): \"\"\" Initialises the database connection and creates tables if they do not already exist. Args: db_name (str): The filename of the database. Defaults to 'bowling.db'. \"\"\" self.db_name = db_name self.conn = sqlite3.connect(self.db_name) self.create_tables() def create_tables(self): \"\"\" Creates tables in the database if they do not exist to store bowlers, alleys, games, and game details. \"\"\" c = self.conn.cursor() # Create tables c.execute(''' CREATE TABLE IF NOT EXISTS Bowlers ( BowlerID INTEGER PRIMARY KEY, Name TEXT UNIQUE, Handedness TEXT, Style TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Alleys ( AlleyID INTEGER PRIMARY KEY, Name TEXT, Location TEXT, LaneType TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS OilPatterns ( PatternID INTEGER PRIMARY KEY, Name TEXT, Description TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Games ( GameID INTEGER PRIMARY KEY, Date TEXT, AlleyID INTEGER, OilPatternID INTEGER, FOREIGN KEY (AlleyID) REFERENCES Alleys(AlleyID), FOREIGN KEY (OilPatternID) REFERENCES OilPatterns(PatternID) ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS GameDetails ( GameID INTEGER, BowlerID INTEGER, FrameData TEXT, TotalScore INTEGER, StrikePercentage REAL, SparePercentage REAL, FOREIGN KEY (GameID) REFERENCES Games(GameID), FOREIGN KEY (BowlerID) REFERENCES Bowlers(BowlerID) ) ''') # Commit changes self.conn.commit() def add_bowler(self, bowler: 'Bowler'): \"\"\" Adds a new bowler to the database or updates an existing bowler with the same name. Args: bowler (Bowler): An instance of the Bowler class containing bowler data. Returns: int: The database ID of the added or updated bowler. \"\"\" c = self.conn.cursor() c.execute(''' INSERT INTO Bowlers (Name, Handedness, Style) VALUES (?, ?, ?) ON CONFLICT(Name) DO UPDATE SET Handedness=excluded.Handedness, Style=excluded.Style ''', (bowler.name, bowler.handedness, bowler.technique)) self.conn.commit() return c.lastrowid def add_alley(self, alley: 'Alley'): \"\"\" Adds a new bowling alley to the database. Args: alley (Alley): An instance of the Alley class containing alley data. Returns: int: The database ID of the added alley. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Alleys (Name, Location, LaneType) VALUES (?, ?, ?)', (alley.name, alley.location, alley.lane_type)) self.conn.commit() return c.lastrowid def add_game(self, date: str, alley_id: int, oil_pattern_id: int, frames: List[Tuple[int, ...]]): \"\"\" Adds a new game along with detailed frame data to the database. Args: date (str): The date the game was played. alley_id (int): The database ID of the alley where the game was played. oil_pattern_id (int): The database ID of the oil pattern used in the game. frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Games (Date, AlleyID, OilPatternID) VALUES (?, ?, ?)', (date, alley_id, oil_pattern_id)) game_id = c.lastrowid total_score, strike_percentage, spare_percentage = self.calculate_stats(frames) c.execute(''' INSERT INTO GameDetails (GameID, FrameData, TotalScore, StrikePercentage, SparePercentage) VALUES (?, ?, ?, ?, ?) ''', (game_id, str(frames), total_score, strike_percentage, spare_percentage)) self.conn.commit() def calculate_stats(self, frames: List[Tuple[int, ...]]) -> Tuple[int, float, float]: \"\"\" Calculate total score, strike, and spare percentages from frame data. Args: frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. Returns: Tuple[int, float, float]: A tuple containing the total score, strike percentage, and spare percentage. \"\"\" total_score = 0 # Implement scoring calculation based on rules strikes = sum(1 for frame in frames if frame[0] == 10) spares = sum(1 for frame in frames if sum(frame[:2]) == 10 and frame[0] != 10) total_frames = len(frames) strike_percentage = (strikes / total_frames) * 100 spare_percentage = (spares / total_frames) * 100 return total_score, strike_percentage, spare_percentage def close(self): \"\"\" Closes the database connection. \"\"\" self.conn.close()","title":"BowlingDatabase Class"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.__init__","text":"Initialises the database connection and creates tables if they do not already exist. Parameters: db_name ( str , default: 'bowling.db' ) \u2013 The filename of the database. Defaults to 'bowling.db'. Source code in trueroll/bowling_database.py def __init__(self, db_name: str = 'bowling.db'): \"\"\" Initialises the database connection and creates tables if they do not already exist. Args: db_name (str): The filename of the database. Defaults to 'bowling.db'. \"\"\" self.db_name = db_name self.conn = sqlite3.connect(self.db_name) self.create_tables()","title":"__init__"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.add_alley","text":"Adds a new bowling alley to the database. Parameters: alley ( Alley ) \u2013 An instance of the Alley class containing alley data. Returns: int \u2013 The database ID of the added alley. Source code in trueroll/bowling_database.py def add_alley(self, alley: 'Alley'): \"\"\" Adds a new bowling alley to the database. Args: alley (Alley): An instance of the Alley class containing alley data. Returns: int: The database ID of the added alley. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Alleys (Name, Location, LaneType) VALUES (?, ?, ?)', (alley.name, alley.location, alley.lane_type)) self.conn.commit() return c.lastrowid","title":"add_alley"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.add_bowler","text":"Adds a new bowler to the database or updates an existing bowler with the same name. Parameters: bowler ( Bowler ) \u2013 An instance of the Bowler class containing bowler data. Returns: int \u2013 The database ID of the added or updated bowler. Source code in trueroll/bowling_database.py def add_bowler(self, bowler: 'Bowler'): \"\"\" Adds a new bowler to the database or updates an existing bowler with the same name. Args: bowler (Bowler): An instance of the Bowler class containing bowler data. Returns: int: The database ID of the added or updated bowler. \"\"\" c = self.conn.cursor() c.execute(''' INSERT INTO Bowlers (Name, Handedness, Style) VALUES (?, ?, ?) ON CONFLICT(Name) DO UPDATE SET Handedness=excluded.Handedness, Style=excluded.Style ''', (bowler.name, bowler.handedness, bowler.technique)) self.conn.commit() return c.lastrowid","title":"add_bowler"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.add_game","text":"Adds a new game along with detailed frame data to the database. Parameters: date ( str ) \u2013 The date the game was played. alley_id ( int ) \u2013 The database ID of the alley where the game was played. oil_pattern_id ( int ) \u2013 The database ID of the oil pattern used in the game. frames ( List [ Tuple [ int , ...]] ) \u2013 A list of tuples representing the frames played in the game. Source code in trueroll/bowling_database.py def add_game(self, date: str, alley_id: int, oil_pattern_id: int, frames: List[Tuple[int, ...]]): \"\"\" Adds a new game along with detailed frame data to the database. Args: date (str): The date the game was played. alley_id (int): The database ID of the alley where the game was played. oil_pattern_id (int): The database ID of the oil pattern used in the game. frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. \"\"\" c = self.conn.cursor() c.execute('INSERT INTO Games (Date, AlleyID, OilPatternID) VALUES (?, ?, ?)', (date, alley_id, oil_pattern_id)) game_id = c.lastrowid total_score, strike_percentage, spare_percentage = self.calculate_stats(frames) c.execute(''' INSERT INTO GameDetails (GameID, FrameData, TotalScore, StrikePercentage, SparePercentage) VALUES (?, ?, ?, ?, ?) ''', (game_id, str(frames), total_score, strike_percentage, spare_percentage)) self.conn.commit()","title":"add_game"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.calculate_stats","text":"Calculate total score, strike, and spare percentages from frame data. Parameters: frames ( List [ Tuple [ int , ...]] ) \u2013 A list of tuples representing the frames played in the game. Returns: Tuple [ int , float , float ] \u2013 Tuple[int, float, float]: A tuple containing the total score, strike percentage, and spare percentage. Source code in trueroll/bowling_database.py def calculate_stats(self, frames: List[Tuple[int, ...]]) -> Tuple[int, float, float]: \"\"\" Calculate total score, strike, and spare percentages from frame data. Args: frames (List[Tuple[int, ...]]): A list of tuples representing the frames played in the game. Returns: Tuple[int, float, float]: A tuple containing the total score, strike percentage, and spare percentage. \"\"\" total_score = 0 # Implement scoring calculation based on rules strikes = sum(1 for frame in frames if frame[0] == 10) spares = sum(1 for frame in frames if sum(frame[:2]) == 10 and frame[0] != 10) total_frames = len(frames) strike_percentage = (strikes / total_frames) * 100 spare_percentage = (spares / total_frames) * 100 return total_score, strike_percentage, spare_percentage","title":"calculate_stats"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.close","text":"Closes the database connection. Source code in trueroll/bowling_database.py def close(self): \"\"\" Closes the database connection. \"\"\" self.conn.close()","title":"close"},{"location":"api/#trueroll.bowling_database.BowlingDatabase.create_tables","text":"Creates tables in the database if they do not exist to store bowlers, alleys, games, and game details. Source code in trueroll/bowling_database.py def create_tables(self): \"\"\" Creates tables in the database if they do not exist to store bowlers, alleys, games, and game details. \"\"\" c = self.conn.cursor() # Create tables c.execute(''' CREATE TABLE IF NOT EXISTS Bowlers ( BowlerID INTEGER PRIMARY KEY, Name TEXT UNIQUE, Handedness TEXT, Style TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Alleys ( AlleyID INTEGER PRIMARY KEY, Name TEXT, Location TEXT, LaneType TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS OilPatterns ( PatternID INTEGER PRIMARY KEY, Name TEXT, Description TEXT ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS Games ( GameID INTEGER PRIMARY KEY, Date TEXT, AlleyID INTEGER, OilPatternID INTEGER, FOREIGN KEY (AlleyID) REFERENCES Alleys(AlleyID), FOREIGN KEY (OilPatternID) REFERENCES OilPatterns(PatternID) ) ''') c.execute(''' CREATE TABLE IF NOT EXISTS GameDetails ( GameID INTEGER, BowlerID INTEGER, FrameData TEXT, TotalScore INTEGER, StrikePercentage REAL, SparePercentage REAL, FOREIGN KEY (GameID) REFERENCES Games(GameID), FOREIGN KEY (BowlerID) REFERENCES Bowlers(BowlerID) ) ''') # Commit changes self.conn.commit()","title":"create_tables"},{"location":"api/#league-class","text":"Source code in trueroll/league.py class League: def __init__(self, name: str, alley: Alley, oil_pattern: str, team_size: int, num_games_per_night: int, season_length: int): \"\"\" Initialises a league with specified parameters, setting up the environment where the league games are played, the type of oil pattern used, the team size, the number of games per league night, and the duration of the season. Args: name (str): The name of the league. alley (Alley): An Alley object where the league games are held. oil_pattern (str): The oil pattern used on the lanes throughout the season. team_size (int): The number of bowlers in each team. num_games_per_night (int): The number of games played each league night. season_length (int): The number of weeks the league runs. Attributes: teams (List[List[Bowler]]): Stores the teams participating in the league. \"\"\" self.name = name self.alley = alley self.oil_pattern = oil_pattern self.team_size = team_size self.num_games_per_night = num_games_per_night self.season_length = season_length self.teams: List[List[Bowler]] = [] # self.teams = [] # List of teams, each team is a list of Bowler objects def add_team(self, team: List[Bowler]): \"\"\" Adds a team to the league. Ensures the team size matches the league's required team size. Args: team (List[Bowler]): A list of Bowler objects making up the team. Raises: ValueError: If the number of bowlers in the team does not match the league's specified team size. \"\"\" if len(team) != self.team_size: raise ValueError(\"Team size must match the league's specified team size\") self.teams.append(team) def run_season(self): \"\"\" Simulates the entire season of the league, organising games per night for each team over the specified season length. Returns: Dict[str, List[Dict[str, float]]]: A dictionary with team names as keys and a list of their average scores per night as values. \"\"\" results = {f\"Team {i+1}\": [] for i in range(len(self.teams))} for week in range(self.season_length): for i, team in enumerate(self.teams): tournament = Tournament(team, self.alley, self.num_games_per_night) tournament.run_tournament() results[f\"Team {i+1}\"].append(tournament.get_average_scores()) return results","title":"League Class"},{"location":"api/#trueroll.league.League.__init__","text":"Initialises a league with specified parameters, setting up the environment where the league games are played, the type of oil pattern used, the team size, the number of games per league night, and the duration of the season. Parameters: name ( str ) \u2013 The name of the league. alley ( Alley ) \u2013 An Alley object where the league games are held. oil_pattern ( str ) \u2013 The oil pattern used on the lanes throughout the season. team_size ( int ) \u2013 The number of bowlers in each team. num_games_per_night ( int ) \u2013 The number of games played each league night. season_length ( int ) \u2013 The number of weeks the league runs. Attributes: teams ( List [ List [ Bowler ]] ) \u2013 Stores the teams participating in the league. Source code in trueroll/league.py def __init__(self, name: str, alley: Alley, oil_pattern: str, team_size: int, num_games_per_night: int, season_length: int): \"\"\" Initialises a league with specified parameters, setting up the environment where the league games are played, the type of oil pattern used, the team size, the number of games per league night, and the duration of the season. Args: name (str): The name of the league. alley (Alley): An Alley object where the league games are held. oil_pattern (str): The oil pattern used on the lanes throughout the season. team_size (int): The number of bowlers in each team. num_games_per_night (int): The number of games played each league night. season_length (int): The number of weeks the league runs. Attributes: teams (List[List[Bowler]]): Stores the teams participating in the league. \"\"\" self.name = name self.alley = alley self.oil_pattern = oil_pattern self.team_size = team_size self.num_games_per_night = num_games_per_night self.season_length = season_length self.teams: List[List[Bowler]] = []","title":"__init__"},{"location":"api/#trueroll.league.League.add_team","text":"Adds a team to the league. Ensures the team size matches the league's required team size. Parameters: team ( List [ Bowler ] ) \u2013 A list of Bowler objects making up the team. Raises: ValueError \u2013 If the number of bowlers in the team does not match the league's specified team size. Source code in trueroll/league.py def add_team(self, team: List[Bowler]): \"\"\" Adds a team to the league. Ensures the team size matches the league's required team size. Args: team (List[Bowler]): A list of Bowler objects making up the team. Raises: ValueError: If the number of bowlers in the team does not match the league's specified team size. \"\"\" if len(team) != self.team_size: raise ValueError(\"Team size must match the league's specified team size\") self.teams.append(team)","title":"add_team"},{"location":"api/#trueroll.league.League.run_season","text":"Simulates the entire season of the league, organising games per night for each team over the specified season length. Returns: \u2013 Dict[str, List[Dict[str, float]]]: A dictionary with team names as keys and a list of their average scores per night as values. Source code in trueroll/league.py def run_season(self): \"\"\" Simulates the entire season of the league, organising games per night for each team over the specified season length. Returns: Dict[str, List[Dict[str, float]]]: A dictionary with team names as keys and a list of their average scores per night as values. \"\"\" results = {f\"Team {i+1}\": [] for i in range(len(self.teams))} for week in range(self.season_length): for i, team in enumerate(self.teams): tournament = Tournament(team, self.alley, self.num_games_per_night) tournament.run_tournament() results[f\"Team {i+1}\"].append(tournament.get_average_scores()) return results","title":"run_season"},{"location":"contact/","text":"Contact Us If you have any questions, need support, or wish to provide feedback about SimNexus, please feel free to reach out. We value your input and are here to help. General Inquiries For general questions about SimNexus or how to use it, please email us at: Email : support@simnexus.com Please allow 24-48 hours for a response, as we strive to provide detailed and helpful answers to all inquiries. Technical Support If you're experiencing technical issues or need help troubleshooting, you can: Submit an Issue : Visit our GitHub Issues Page to report a bug or a problem. Please check to see if your issue has already been reported or addressed before opening a new issue. Feature Requests We are always looking to improve SimNexus and welcome your ideas and proposals for new features: Feature Suggestions : Please submit your feature requests through our GitHub Issues Page . Tag your post with the 'feature request' label so we can easily identify it. Follow Us Stay updated on the latest developments and updates of SimNexus by following us on social media: Twitter : @SimNexusTech LinkedIn : SimNexus Technologies Mailing List Join our mailing list to receive updates, news, and special offers related to SimNexus: Sign Up : Join Mailing List [Link to mailing list subscription form] Thank you for your interest in SimNexus. We look forward to hearing from you and assisting you with your simulation needs!","title":"Contact"},{"location":"contact/#contact-us","text":"If you have any questions, need support, or wish to provide feedback about SimNexus, please feel free to reach out. We value your input and are here to help.","title":"Contact Us"},{"location":"contact/#general-inquiries","text":"For general questions about SimNexus or how to use it, please email us at: Email : support@simnexus.com Please allow 24-48 hours for a response, as we strive to provide detailed and helpful answers to all inquiries.","title":"General Inquiries"},{"location":"contact/#technical-support","text":"If you're experiencing technical issues or need help troubleshooting, you can: Submit an Issue : Visit our GitHub Issues Page to report a bug or a problem. Please check to see if your issue has already been reported or addressed before opening a new issue.","title":"Technical Support"},{"location":"contact/#feature-requests","text":"We are always looking to improve SimNexus and welcome your ideas and proposals for new features: Feature Suggestions : Please submit your feature requests through our GitHub Issues Page . Tag your post with the 'feature request' label so we can easily identify it.","title":"Feature Requests"},{"location":"contact/#follow-us","text":"Stay updated on the latest developments and updates of SimNexus by following us on social media: Twitter : @SimNexusTech LinkedIn : SimNexus Technologies","title":"Follow Us"},{"location":"contact/#mailing-list","text":"Join our mailing list to receive updates, news, and special offers related to SimNexus: Sign Up : Join Mailing List [Link to mailing list subscription form] Thank you for your interest in SimNexus. We look forward to hearing from you and assisting you with your simulation needs!","title":"Mailing List"},{"location":"contribute/","text":"Contribute to Our Project We welcome contributions from the community. Before contributing, please read our contribution guidelines to understand how you can help improve this project. Read the Contribution Guidelines","title":"Contribute"},{"location":"contribute/#contribute-to-our-project","text":"We welcome contributions from the community. Before contributing, please read our contribution guidelines to understand how you can help improve this project. Read the Contribution Guidelines","title":"Contribute to Our Project"}]}